*** expat/xmlparse/xmlparse.c.orig	Sun Dec 27 10:00:12 1998
--- expat/xmlparse/xmlparse.c	Sat Feb 20 21:32:25 1999
***************
*** 72,77 ****
--- 72,81 ----
  
  #define EXPAND_SPARE 24
  
+ /* On macintosh, '\n' may get translated to 0xD instead of 0xA */
+ #define CR '\015'
+ #define LF '\012'
+ 
  typedef struct binding {
    struct prefix *prefix;
    struct binding *nextTagBinding;
***************
*** 820,825 ****
--- 824,836 ----
    return -1;
  }
  
+ long XML_GetCurrentByteLimit(XML_Parser parser)
+ {
+   if (eventPtr)
+     return parseEndByteIndex - (parseEndPtr - eventEndPtr);
+   return -1;
+ }
+ 
  int XML_GetCurrentLineNumber(XML_Parser parser)
  {
    if (eventPtr) {
***************
*** 1013,1019 ****
        }
        *eventEndPP = end;
        if (characterDataHandler) {
! 	XML_Char c = XML_T('\n');
  	characterDataHandler(handlerArg, &c, 1);
        }
        else if (defaultHandler)
--- 1024,1030 ----
        }
        *eventEndPP = end;
        if (characterDataHandler) {
! 	XML_Char c = XML_T(LF);
  	characterDataHandler(handlerArg, &c, 1);
        }
        else if (defaultHandler)
***************
*** 1168,1173 ****
--- 1179,1185 ----
  	}
  	++tagLevel;
  	if (startElementHandler) {
+ 	  int i;
  	  enum XML_Error result;
  	  XML_Char *toPtr;
  	  for (;;) {
***************
*** 1197,1202 ****
--- 1209,1220 ----
  	  if (result)
  	    return result;
  	  startElementHandler(handlerArg, tag->name, (const XML_Char **)atts);
+ 	  for (i = 0; i < attsSize; i += 2) {
+ 	    if (! ((XML_Char **) atts)[i])
+ 	      break;
+ 
+ 	    (((XML_Char **) atts)[i])[-1] = 0;
+ 	  }
  	  poolClear(&tempPool);
  	}
  	else {
***************
*** 1228,1235 ****
  	if (result)
  	  return result;
  	poolFinish(&tempPool);
! 	if (startElementHandler)
  	  startElementHandler(handlerArg, name, (const XML_Char **)atts);
  	if (endElementHandler) {
  	  if (startElementHandler)
  	    *eventPP = *eventEndPP;
--- 1246,1261 ----
  	if (result)
  	  return result;
  	poolFinish(&tempPool);
! 	if (startElementHandler) {
! 	  int i;
  	  startElementHandler(handlerArg, name, (const XML_Char **)atts);
+ 	  for (i = 0; i < attsSize; i += 2) {
+ 	    if (! ((XML_Char **) atts)[i])
+ 	      break;
+ 
+ 	    (((XML_Char **) atts)[i])[-1] = 0;
+ 	  }
+ 	}
  	if (endElementHandler) {
  	  if (startElementHandler)
  	    *eventPP = *eventEndPP;
***************
*** 1299,1305 ****
        return XML_ERROR_MISPLACED_XML_PI;
      case XML_TOK_DATA_NEWLINE:
        if (characterDataHandler) {
! 	XML_Char c = XML_T('\n');
  	characterDataHandler(handlerArg, &c, 1);
        }
        else if (defaultHandler)
--- 1325,1331 ----
        return XML_ERROR_MISPLACED_XML_PI;
      case XML_TOK_DATA_NEWLINE:
        if (characterDataHandler) {
! 	XML_Char c = XML_T(LF);
  	characterDataHandler(handlerArg, &c, 1);
        }
        else if (defaultHandler)
***************
*** 1513,1526 ****
  	      return XML_ERROR_NO_MEMORY;
  	  }
            else {
! 	    (da->id->name)[-1] = 2;
  	    nPrefixes++;
    	    appAtts[attIndex++] = da->id->name;
  	    appAtts[attIndex++] = da->value;
  	  }
  	}
  	else {
! 	  (da->id->name)[-1] = 1;
  	  appAtts[attIndex++] = da->id->name;
  	  appAtts[attIndex++] = da->value;
  	}
--- 1539,1552 ----
  	      return XML_ERROR_NO_MEMORY;
  	  }
            else {
! 	    (da->id->name)[-1] = 6;
  	    nPrefixes++;
    	    appAtts[attIndex++] = da->id->name;
  	    appAtts[attIndex++] = da->value;
  	  }
  	}
  	else {
! 	  (da->id->name)[-1] = 5;
  	  appAtts[attIndex++] = da->id->name;
  	  appAtts[attIndex++] = da->value;
  	}
***************
*** 1531,1537 ****
    i = 0;
    if (nPrefixes) {
      for (; i < attIndex; i += 2) {
!       if (appAtts[i][-1] == 2) {
          ATTRIBUTE_ID *id;
          ((XML_Char *)(appAtts[i]))[-1] = 0;
  	id = (ATTRIBUTE_ID *)lookup(&dtd.attributeIds, appAtts[i], 0);
--- 1557,1563 ----
    i = 0;
    if (nPrefixes) {
      for (; i < attIndex; i += 2) {
!       if ((appAtts[i][-1] & 3) == 2) {
          ATTRIBUTE_ID *id;
          ((XML_Char *)(appAtts[i]))[-1] = 0;
  	id = (ATTRIBUTE_ID *)lookup(&dtd.attributeIds, appAtts[i], 0);
***************
*** 1559,1568 ****
  	((XML_Char *)(appAtts[i]))[-1] = 0;
      }
    }
!   for (; i < attIndex; i += 2)
!     ((XML_Char *)(appAtts[i]))[-1] = 0;
!   if (!tagNamePtr)
      return XML_ERROR_NONE;
    for (binding = *bindingsPtr; binding; binding = binding->nextTagBinding)
      binding->attId->name[-1] = 0;
    if (elementType->prefix) {
--- 1585,1595 ----
  	((XML_Char *)(appAtts[i]))[-1] = 0;
      }
    }
!   if (!tagNamePtr) {
!     for (; i < attIndex; i += 2)
!       ((XML_Char *)(appAtts[i]))[-1] = 0;
      return XML_ERROR_NONE;
+   }
    for (binding = *bindingsPtr; binding; binding = binding->nextTagBinding)
      binding->attId->name[-1] = 0;
    if (elementType->prefix) {
***************
*** 1695,1701 ****
        return XML_ERROR_NONE;
      case XML_TOK_DATA_NEWLINE:
        if (characterDataHandler) {
! 	XML_Char c = XML_T('\n');
  	characterDataHandler(handlerArg, &c, 1);
        }
        else if (defaultHandler)
--- 1722,1728 ----
        return XML_ERROR_NONE;
      case XML_TOK_DATA_NEWLINE:
        if (characterDataHandler) {
! 	XML_Char c = XML_T(LF);
  	characterDataHandler(handlerArg, &c, 1);
        }
        else if (defaultHandler)
***************
*** 2421,2427 ****
      case XML_TOK_DATA_NEWLINE:
        if (pool->end == pool->ptr && !poolGrow(pool))
  	return XML_ERROR_NO_MEMORY;
!       *(pool->ptr)++ = XML_T('\n');
        break;
      case XML_TOK_CHAR_REF:
        {
--- 2448,2454 ----
      case XML_TOK_DATA_NEWLINE:
        if (pool->end == pool->ptr && !poolGrow(pool))
  	return XML_ERROR_NO_MEMORY;
!       *(pool->ptr)++ = XML_T(LF);
        break;
      case XML_TOK_CHAR_REF:
        {
***************
*** 2465,2478 ****
    for (;; s++) {
      if (*s == XML_T('\0'))
        return;
!     if (*s == XML_T('\r'))
        break;
    }
    p = s;
    do {
!     if (*s == XML_T('\r')) {
!       *p++ = XML_T('\n');
!       if (*++s == XML_T('\n'))
          s++;
      }
      else
--- 2492,2505 ----
    for (;; s++) {
      if (*s == XML_T('\0'))
        return;
!     if (*s == XML_T(CR))
        break;
    }
    p = s;
    do {
!     if (*s == XML_T(CR)) {
!       *p++ = XML_T(LF);
!       if (*++s == XML_T(LF))
          s++;
      }
      else
***************
*** 2800,2807 ****
    for (s = publicId; *s; s++) {
      switch (*s) {
      case XML_T(' '):
!     case XML_T('\r'):
!     case XML_T('\n'):
        if (p != publicId && p[-1] != XML_T(' '))
  	*p++ = XML_T(' ');
        break;
--- 2827,2834 ----
    for (s = publicId; *s; s++) {
      switch (*s) {
      case XML_T(' '):
!     case XML_T(CR):
!     case XML_T(LF):
        if (p != publicId && p[-1] != XML_T(' '))
  	*p++ = XML_T(' ');
        break;
*** expat/xmlparse/xmlparse.h.orig	Mon Jan  4 08:22:26 1999
--- expat/xmlparse/xmlparse.h	Sat Feb 20 18:32:31 1999
***************
*** 410,415 ****
--- 410,416 ----
  int XMLPARSEAPI XML_GetCurrentLineNumber(XML_Parser parser);
  int XMLPARSEAPI XML_GetCurrentColumnNumber(XML_Parser parser);
  long XMLPARSEAPI XML_GetCurrentByteIndex(XML_Parser parser);
+ long XMLPARSEAPI XML_GetCurrentByteLimit(XML_Parser parser);
  
  /* For backwards compatibility with previous versions. */
  #define XML_GetErrorLineNumber XML_GetCurrentLineNumber
